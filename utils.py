import cplex
from cplex.exceptions import CplexError
Err = 1e-6

class Winner:
    def __init__(self,bid_information, bid_prices, bid_items,dummy_bids,winners):
        self.win_bids = winners
        self.win_prices = [bid_prices[i] for i in winners]
        self.win_items = [bid_items[i] for i in winners]

        self.dummy_goods = {}
        self.all_bids = []
        self.all_prices = []
        for i in winners:
            if bid_items[i][-1] >= bid_information['goods']:
                self.dummy_goods[bid_items[i][-1]] = i
                for j in dummy_bids[bid_items[i][-1]]:
                    self.all_bids.append(j)
                    self.all_prices.append(bid_prices[j])

            else:
                self.all_bids.append(i)
                self.all_prices.append(bid_prices[i])






def read_bidfile(filename):
    '''

    :param filename: file name which generated by CATS
    :return:
    bid_information:

    bid_price:

    bid_items:

    dummy_bid:
    '''

    bid_information = dict()
    dummy_bids = dict()
    bid_prices = []
    bid_items = []

    with open(filename) as f:
        for line in f.readlines():
            line = line.partition('%')[0]
            if not line or line=='\n':
                continue

            line_list = line.split()
            if not line_list[0].isdigit():
                bid_information[line_list[0]] = int(line_list[1])
                if line_list[0]=='dummy':
                    goods_num = bid_information['goods']
                    bids_num = bid_information['bids']
                    dummy_num = bid_information['dummy']

                    #dummy good: goods_num<=  dummy good index <goods_num+dummy_num

                    for i in range(goods_num,goods_num+dummy_num):
                        dummy_bids[i] = []
            else:
                if int(line_list[-2]) >= goods_num:
                    dummy_bids[int(line_list[-2])].append(int(line_list[0]))

                if line_list[1] == '-nan':
                    bid_prices.append(0.0)
                else:
                    bid_prices.append(float(line_list[1]))
                bid_items.append(list(map(int, line_list[2:-1])))

        return bid_information, bid_prices, bid_items, dummy_bids




def Winner_determination(bid_information, bid_prices, bid_items):
    '''
    :param bid_prices: the bid price of bidders, including the dummy good, each agent has one bid
    :param bid_items: the corresponding bid price of bidders, including the dummy good, each agent has one bid
    :param bid_information: A dict with the key 'goods','bids','dummy'

    :return:
    social_wefare: Maximum social welfare
    my_winners: the indexes of winner bids
    winner_price: the price of winner bids
    winner_items: the bid items of winner bids
    winner_dummy_goods: the dummy goods of winners
    '''

    goods_totoal_num = bid_information['goods']+bid_information['dummy']
    bids_num =  bid_information['bids']
### objective, xi indicates whether the bid is selected.
    my_obj = bid_prices
    my_ub = [1.0] * bids_num
    my_lb = [0.0] * bids_num
    my_ctype = "I" * bids_num
    my_colnames=[]
    for i in range(bids_num):
        my_colnames.append("x" + str(i))

## include the constraint that each good can only be sold once.
# example: row = [['x1','x2'],[1.0, 2.0]], sense = 'L', rhs = 10
#          meaning:     x1 + 2x2 <= 10


    my_rows = []
    row=[[],[]]
    for good in range(goods_totoal_num):
        for i in range(bids_num):
            if good in bid_items[i]:
                row[0].append('x'+str(i))
                row[1].append(1.0)
        my_rows.append(row)
        row=[[],[]]

    my_rhs = [1.0 for _ in range(len(my_rows))]
    my_sense = "L" * len(my_rows)

##  set the cplex parameters
    Prob = cplex.Cplex()
    Prob.set_results_stream(None)
    Prob.variables.add(obj=my_obj, lb=my_lb, ub=my_ub, types=my_ctype, names=my_colnames)
    Prob.linear_constraints.add(lin_expr=my_rows, senses=my_sense, rhs=my_rhs)
    Prob.set_problem_type(cplex.Cplex.problem_type.MILP)
    Prob.objective.set_sense(Prob.objective.sense.maximize)

## solve the winner determination problem
    # Prob.write('test1.lp')  # see what the problem is
    try:
        ## try to get the optimal solution
        Prob.parameters.mip.tolerances.mipgap.set(float(0))
        Prob.solve()
    except CplexError as exc:
        print(exc)


## get the solution, solution is binary variable which indicates whether bid i is selected, xi = 1: winner
    solution = Prob.solution.get_values()
    social_wefare = Prob.solution.get_objective_value()

    winners = []
    for i in range(bids_num):
        if solution[i] >= 0.999:
            winners.append(i)
    # print(sum([bid_prices[i] for i in winners]),social_wefare,winners)
    # print(winners)
    return social_wefare, winners


def truncate_bids(bid_information, bid_prices, bid_items, dummy_bids, utility):
    for i in utility:
        if utility[i] != 0:
            if bid_items[i][-1] >= bid_information['goods']:
                for j in dummy_bids[bid_items[i][-1]]:
                    bid_prices[j] = max(bid_prices[j] - utility[i], 0)
            else:
                bid_prices[i] = max(bid_prices[i] - utility[i], 0)



def change_bids(bid_information, bid_prices, bid_items, dummy_bids, utility):
    for i in utility:
        if utility[i] != 0:
            if bid_items[i][-1] >= bid_information['goods']:
                for j in dummy_bids[bid_items[i][-1]]:
                    bid_prices[j] = bid_prices[j] - utility[i]
            else:
                bid_prices[i] = bid_prices[i] - utility[i]




def save_bids(bid_information, dummy_bid, bid_price, bid_items, save_bidders):
    '''
    :param bid_information:
    :param dummy_bid:
    :param bid_price:
    :param bid_items:
    :param save_bidders:
    :return:
    '''
    save_bids = {}
    for i in save_bidders:
        if bid_items[i][-1]>=bid_information['goods']:
            for j in dummy_bid[bid_items[i][-1]]:
                save_bids[j] = bid_price[j]
        else:
            save_bids[i] = bid_price[i]

    return save_bids


def recover_bids(bid_prices, recover_bids, recover_prices):
    '''

    :param bid_price:
    :param recover_bids:
    :return:
    '''
    for i in range(len(recover_bids)):
        bid_prices[recover_bids[i]] = recover_prices[i]

def transform_bids(bid_information, bid_items, Winners, bids):
    transformed_bids = bids
    for i in range(len(bids)):
        if bid_items[bids[i]][-1] >= bid_information['goods']:
            if bid_items[bids[i]][-1] in Winners.dummy_goods.keys():
                transformed_bids[i] = Winners.dummy_goods[bid_items[bids[i]][-1]]

    return transformed_bids


def intersection(listA,listB):
    #求交集
    return list(set(listA).intersection(set(listB)))

def diff(listA,listB):
    #求差集
    return list(set(listA).difference(set(listB)))

def union(listA,listB):
    #求并集
    return list(set(listA).union(set(listB)))




def K_Winner_determination(bid_information, bid_prices, bid_items,dummy_bids,Active_winners,K):

    goods_totoal_num = bid_information['goods']+bid_information['dummy']
    bids_num =  bid_information['bids']
### objective, xi indicates whether the bid is selected.
    my_obj = bid_prices
    my_ub = [1.0] * bids_num
    my_lb = [0.0] * bids_num
    my_ctype = "I" * bids_num
    my_colnames=[]
    for i in range(bids_num):
        my_colnames.append("x" + str(i))

## include the constraint that each good can only be sold once.
# example: row = [['x1','x2'],[1.0, 2.0]], sense = 'L', rhs = 10
#          meaning:     x1 + 2x2 <= 10


    my_rows = []
    row=[[],[]]
    for good in range(goods_totoal_num):
        for i in range(bids_num):
            if good in bid_items[i]:
                row[0].append('x'+str(i))
                row[1].append(1.0)
        my_rows.append(row)
        row=[[],[]]
    my_rhs = [1.0 for _ in range(len(my_rows))]
    my_sense = "L" * len(my_rows)


    row = [[], []]
    for i in Active_winners:
        if bid_items[i][-1]  >= bid_information['goods']:
            for j in dummy_bids[bid_items[i][-1]]:
                row[0].append('x'+str(j))
                row[1].append(1.0)
        else:
            row[0].append('x' + str(i))
            row[1].append(1.0)
    my_rows.append(row)
    my_rhs += [float(K)]
    my_sense +='E'



##  set the cplex parameters
    Prob = cplex.Cplex()
    Prob.set_results_stream(None)
    Prob.variables.add(obj=my_obj, lb=my_lb, ub=my_ub, types=my_ctype, names=my_colnames)
    Prob.linear_constraints.add(lin_expr=my_rows, senses=my_sense, rhs=my_rhs)
    Prob.set_problem_type(cplex.Cplex.problem_type.MILP)
    Prob.objective.set_sense(Prob.objective.sense.maximize)

## solve the winner determination problem
# Prob.write('test1.lp')  # see what the problem is
    try:
        ## try to get the optimal solution
        Prob.parameters.mip.tolerances.mipgap.set(float(0))
        Prob.solve()
    except CplexError as exc:
        print(exc)

    # Prob.write('test.lp')
## get the solution, solution is binary variable which indicates whether bid i is selected, xi = 1: winner
    solution = Prob.solution.get_values()
    social_wefare = Prob.solution.get_objective_value()

    winners = []
    for i in range(bids_num):
        if solution[i] >= 1-Err:
            winners.append(i)

    return social_wefare, winners

